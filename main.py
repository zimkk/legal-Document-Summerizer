import os
import sys
import time
import logging
from datetime import datetime
from langchain_community.llms import Ollama
import PyPDF2
from docx import Document
import re
# from concurrent.futures import ThreadPoolExecutor

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Loading the model
try:
    llm = Ollama(model="legal-summarizer")  # Using custom legal-specific model
    logger.info("Model 'legal-summarizer' loaded successfully.")
except Exception as e:
    logger.error(f"Failed to load model: {e}")
    sys.exit(1)

DEFAULT_DIRECTORY = os.getenv("DEFAULT_DIRECTORY", "documents")
OUTPUT_DIRECTORY = os.getenv("OUTPUT_DIRECTORY", os.path.join(os.getcwd(), "refined"))

if not os.path.exists(OUTPUT_DIRECTORY):
    os.makedirs(OUTPUT_DIRECTORY)
    logger.info(f"Created output directory: {OUTPUT_DIRECTORY}")

def build_prompt(text):
    return f"""
You are a professional legal document summarizer AI. Your task is to analyze and summarize the following legal document in a clear, structured format.

Please provide a comprehensive summary following this exact structure:

===========================================
GENERATED BY: AI LEGAL SUMMARIZER
DATE: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
===========================================

1. DOCUMENT IDENTIFICATION
-------------------------
Title: [Full title of the case or document]
Document Number: [Case number, docket number, or reference number]
Date: [Date of the document or ruling]
Court/Jurisdiction: [Name of the court or jurisdiction]
Judge/Author: [Name of the presiding judge or document author]

2. PARTIES INVOLVED
------------------
Plaintiff/Appellant: [Name and role]
Defendant/Respondent: [Name and role]
Other Relevant Parties: [List any other significant parties]

3. CASE SUMMARY
--------------
Background: [Brief context of the case]
Key Issues: [List the main legal questions or matters addressed]
Arguments Presented: [Summary of main arguments from both sides]

4. LEGAL ANALYSIS
----------------
Applicable Laws: [Relevant statutes, regulations, or legal principles]
Precedents Cited: [Important case law references]
Legal Reasoning: [Court's or document's legal analysis]

5. DECISION/OUTCOME
------------------
Ruling: [The final decision or outcome]
Relief Granted: [Any remedies, damages, or relief awarded]
Conditions/Orders: [Any specific conditions or orders issued]

6. IMPLICATIONS
--------------
Legal Impact: [Significance of the decision]
Practical Implications: [Real-world consequences]
Future Considerations: [Potential future implications]

7. ADDITIONAL NOTES
------------------
Confidentiality Level: [If applicable]
Related Cases: [Any connected cases or documents]
Special Considerations: [Any unique aspects or important notes]

===========================================
END OF SUMMARY
===========================================

Important Guidelines:
- Maintain a professional and objective tone
- Use clear, concise language
- Focus on factual information
- Avoid personal opinions or interpretations
- Ensure all information is directly from the document
- Format consistently with the provided structure
- Use proper legal terminology
- Highlight any critical deadlines or time-sensitive information

Document to be summarized:
{text}
"""

def extract_text_from_pdf(file_path):
    logger.info(f"Extracting text from PDF: {file_path}")
    text = ""
    try:
        with open(file_path, "rb") as f:
            reader = PyPDF2.PdfReader(f)
            if len(reader.pages) == 0:
                logger.error("PDF file has no pages")
                return ""
            for page in reader.pages:
                try:
                    page_text = page.extract_text()
                    if page_text:
                        text += page_text + "\n"
                    else:
                        logger.warning("Empty page text extracted")
                except Exception as page_error:
                    logger.error(f"Error extracting text from page: {str(page_error)}")
    except Exception as e:
        logger.error(f"Error reading PDF: {str(e)}")
        raise
    return text.strip()

def extract_text_from_docx(file_path):
    logger.info(f"Extracting text from DOCX: {file_path}")
    text = ""
    try:
        doc = Document(file_path)
        if len(doc.paragraphs) == 0:
            logger.error("DOCX file has no paragraphs")
            return ""
        for para in doc.paragraphs:
            if para.text:
                text += para.text + "\n"
            else:
                logger.warning("Empty paragraph found")
    except Exception as e:
        logger.error(f"Error reading DOCX: {str(e)}")
        raise
    return text.strip()

def clean_text(text):
    logger.info("Cleaning extracted text...")
    if not text:
        logger.error("No text provided for cleaning")
        return ""
    try:
        # Remove non-printable characters
        text = re.sub(r'[^\x20-\x7E\n]+', ' ', text)
        # Normalize whitespace
        text = re.sub(r'\s+', ' ', text)
        # Remove multiple newlines
        text = re.sub(r'\n\s*\n', '\n\n', text)
        cleaned = text.strip()
        if not cleaned:
            logger.error("Text is empty after cleaning")
        return cleaned
    except Exception as e:
        logger.error(f"Error cleaning text: {str(e)}")
        raise

def generate_summary(text):
    if not text:
        logger.error("No text provided for summarization")
        return "Error: No text to summarize."

    MAX_CHARS = 8000  # Increased context window
    if len(text) > MAX_CHARS:
        logger.warning(f"Text length ({len(text)}) exceeds maximum ({MAX_CHARS}). Truncating...")
        text = text[:MAX_CHARS]

    prompt = build_prompt(text)
    logger.info("Generating summary...")
    try:
        logger.debug(f"Prompt preview:\n{prompt[:200]}...\n...{prompt[-200:]}")
        start = time.time()
        
        # Configure model parameters for better summarization
        summary = llm.invoke(
            prompt,
            temperature=0.3,  # Lower temperature for more focused output
            top_p=0.9,       # Higher top_p for better quality
            num_ctx=4096     # Maximum context window
        )
        
        duration = time.time() - start
        logger.info(f"Summary generated in {duration:.2f} seconds.")
        
        if not summary:
            logger.error("Model returned empty summary")
            return "Error: Summary generation failed. Please try again."
            
        summary = summary.strip()
        if len(summary) < 100:
            logger.warning(f"Generated summary seems too short ({len(summary)} characters)")
            return "Error: Generated summary is too short. Please try again."
            
        # Validate summary structure
        required_sections = [
            "DOCUMENT IDENTIFICATION",
            "PARTIES INVOLVED",
            "CASE SUMMARY",
            "LEGAL ANALYSIS",
            "DECISION/OUTCOME",
            "IMPLICATIONS",
            "ADDITIONAL NOTES"
        ]
        
        missing_sections = [section for section in required_sections if section not in summary]
        if missing_sections:
            logger.warning(f"Summary missing required sections: {missing_sections}")
            return "Error: Generated summary is incomplete. Please try again."
            
        return summary
    except Exception as e:
        logger.exception("Exception during model invocation.")
        return f"Error generating summary: {str(e)}"

def export_to_word(summary_text, output_path):
    logger.info(f"Exporting summary to {output_path}")
    try:
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        doc = Document()
        doc.add_heading("Legal Document Summary", 0)
        doc.add_paragraph(summary_text)
        doc.save(output_path)
        logger.info("Export complete.")
    except Exception as e:
        logger.error(f"Failed to export Word document: {e}")

def process_file(file_path):
    logger.info(f"Starting to process file: {file_path}")
    
    # Step 1: Extract text
    logger.info("Step 1: Extracting text from file...")
    if file_path.endswith(".pdf"):
        raw_text = extract_text_from_pdf(file_path)
    elif file_path.endswith(".docx"):
        raw_text = extract_text_from_docx(file_path)
    else:
        logger.warning(f"Unsupported file type: {file_path}")
        return
    logger.info(f"Text extraction complete. Length: {len(raw_text)} characters")

    # Step 2: Clean text
    logger.info("Step 2: Cleaning text...")
    cleaned_text = clean_text(raw_text)
    logger.info(f"Text cleaning complete. Length: {len(cleaned_text)} characters")

    # Step 3: Generate summary
    logger.info("Step 3: Generating summary...")
    summary = generate_summary(cleaned_text)
    logger.info("Summary generation complete")

    # Step 4: Export to Word
    logger.info("Step 4: Exporting to Word...")
    base_name = os.path.basename(file_path)
    name_without_ext = os.path.splitext(base_name)[0]
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = os.path.join(OUTPUT_DIRECTORY, f"{name_without_ext}_Summary_{timestamp}.docx")
    export_to_word(summary, output_file)
    logger.info(f"Summary exported to {output_file}")
